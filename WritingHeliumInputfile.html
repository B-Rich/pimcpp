<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Changing System Parameters &mdash; PIMC++ 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="PIMC++ 1.0.0 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="index.html">PIMC++ 1.0.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <p>We are converting the Single Particle input file to one that is useful
for Helium.</p>
<p>There are four key steps to converting the input file.</p>
<ol class="arabic simple">
<li>Changing System Parameters (particle number, type, name, lambda and
simulation box size)</li>
<li>Switching particle statistics from boltzmannon to boson</li>
<li>Getting the correct pair interaction for the Helium atoms (and
choosing a time step <img alt="http://latex.codecogs.com/gif.latex?%5Ctau" src="http://latex.codecogs.com/gif.latex?%5Ctau" />)</li>
<li>Setting up observables.</li>
</ol>
<div class="section" id="changing-system-parameters">
<h1>Changing System Parameters<a class="headerlink" href="#changing-system-parameters" title="Permalink to this headline">¶</a></h1>
<p>To accomplish this, first let&#8217;s change the species <em>Type</em> (Section:
System/Particles/Species) from &#8220;free&#8221; to &#8220;He&#8221;. Let&#8217;s also change
<em>lambda</em> (Section: System/Particle/Species) to the correct value of
lambda (the inverse mass) for He-4 which is
<a class="reference external" href="lambdaforHe-4">6.059615</a>. We will do our simulation with 10 Helium
particles (in practice, this is too small to get accurate results for
the bulk, but we want our simulation to run in a reasonable time frame).
Therefore, set <em>NumParticles</em> (Section: System/Particles/Species) to 10.
Standard volume and pressure (SVP) is a number density of
<span class="math">\(0.02182 \AA^{-3}\)</span>, which corresponds to a Box (Section: System)
with sides <span class="math">\(7.709894 \AA\)</span>.</p>
<p>Now, we want the output file to be named differently. Therefore, change
the <em>OutFileBase</em> (Section: Observables) to Helium.</p>
<p>Finally, there is the <em>Name</em> of the Species used throughout the input
file. It is specified by you, the user, and can be anything (myParticle,
He, free, etc.) as long as it is consistent throughout the input file.
(<em>Name</em> of a Species is distinct from <em>Type</em> for reasons that will
become apparent later). The <em>Name</em> is currently set to &#8220;free&#8221;, which is
somewhat confusing for He-4 particles. Instead, change all (three)
instances of &#8220;free&#8221; to &#8220;Helium4&#8221; in the input (<em>Name</em> (Section:
System/Particles/Species), <em>Species</em> (Section: Moves/Move) and <em>Species</em>
(Section: Observables/Observable))</p>
</div>
<div class="section" id="particle-statistics">
<h1>Particle Statistics<a class="headerlink" href="#particle-statistics" title="Permalink to this headline">¶</a></h1>
<p>Helium is a boson. In path integral Monte Carlo, it is typical to sample
the bosonic density matrix by <a class="reference external" href="BosonPicture">explicitly integrating over
permutations</a>, or &#8220;sampling permutations.&#8221; This means
that the Metropolis formalism is employed to propose and
probabilistically accept exchanges of beads between different particles.
When an exchange (permutation) is accepted, two or more polymers become
linked to form a single polymer.</p>
<p>We must now tell PIMC++ to use bosons. For the single free particle, the
<em>Statistics</em> variable was set to &#8220;BOLTZMANNON&#8221;, meaning all particles
(if there were more than one) are distinguishable. Inside the Helium
species section, change <em>Statistics</em> (Section: System/Particles/Species)
from &#8220;BOLTZMANNON&#8221; to &#8220;BOSON&#8221;.</p>
<p>Now, there are different moves that can sample over permutations. We
have to specify how we want this sampling done. For this tutorial, we
will use the BisectionBlock move (like we did for free particles) with
the addition that it will attempt to sample over all four particle
permutations. To modify the algorithm appropriately, we must go to the
BisectionBlock move and change <em>PermuteType</em> (Section: Moves/Move) from
&#8220;NONE&#8221; to &#8220;TABLE&#8221;.</p>
<p>When the <em>PermuteType</em> is &#8220;TABLE&#8221;, we have to specify some additional
parameters. Here we will give a brief overview of these parameters, but
for an in-depth explanation of them, please look
<a class="reference external" href="Moves#Bisection_Block">here</a> in the documentation. The table samples
all possible 1,2,3, and 4 particle permutations with a probability
(approximately) proportional to their kinetic action. Because 2, 3, and
4 particle permutations are important but typically have a much smaller
kinetic action, we may want to increase the likelihood that they are
sampled. We do this by multiplying their probability by some factor. In
the input, we want to add the variable <em>Array Gamma(4)</em> (Section:
Moves/Move) parameter and set it to [1.0,20.0,100.0,400.0]. This means
that four particle permutations will be attempted with a likelihood 400
times greater than if only the kinetic action were used to compute the
transition probability. (nb: all these numbers must be greater then 1)</p>
<p>The other important parameter is <em>double epsilon</em> (Section: Moves/Move).
This value specifies the smallest probability that is kept in the table.
Because the table is naively <span class="math">\(N^4\)</span>, this is a useful numerical
approximation that dramatically increases the efficiency of the
algorithm. Add this variable and set it to 1e-5. (Note that doing so
introduces a small numerical approximation into the code)</p>
<p>Remember that if you are editing the input file as you go, you will need
to add a semicolon &#8221;;&#8221; at the end of each new line of input to conform
to standard C++ syntax!</p>
</div>
<div class="section" id="generating-density-matrix">
<h1>Generating density matrix<a class="headerlink" href="#generating-density-matrix" title="Permalink to this headline">¶</a></h1>
<div class="line-block">
<div class="line">Path Integral Monte Carlo calculates integrals of the following form:</div>
<div class="line">:math:` frac{1}{Z} int rho(R,R;beta) O(R) dR` where</div>
</div>
<p><span class="math">\(\rho(R)\)</span> is the many body density matrix and <span class="math">\(O(R)\)</span> is some
observable. It accomplishes this by developing the density matrix at
<span class="math">\(\beta\)</span> as a convolution of <span class="math">\(M=\frac{\beta}{\tau}\)</span> density
matrices at <span class="math">\(\tau\)</span>
| <span class="math">\(\int \rho(R;\beta) = \int\rho(R,R';\tau)\rho(R',R'',\tau)...\rho(R'''',R) dR dR' dR''...\)</span></p>
<p>This is done because we don&#8217;t know how to accurately approximate
<span class="math">\(\rho(R,R;\beta)\)</span>, much less write an exact expression. However,
we can use a good approximation for <span class="math">\(\rho(R,R';\tau)\)</span>, the high
temperature many body density matrix (remember that <span class="math">\(\beta\)</span> and
<span class="math">\(\tau\)</span> are inverse temperatures, so small <span class="math">\(\tau\)</span> corresponds
to a high temperature).</p>
<p>We will now discuss how (and why) we approximate the high temperature
density matrix. The high temperature density matrix is exactly
<span class="math">\(\left&lt;R|\exp[-\tau(\hat{T}+\hat{V})] |R'\right&gt;\)</span>.</p>
<div class="line-block">
<div class="line">Because we don&#8217;t have exact eigenvalues for the operator</div>
</div>
<p><span class="math">\(\exp[-\tau(\hat{T}+\hat{V})]\)</span> with an arbitrary potential, we
have to introduce an approximation. The standard approach is to do a
Trotter breakup, disregarding the commutator between the kinetic and
potential action operators, and write it approximately as
| <span class="math">\(\left&lt;R|\exp[-(\tau/2)\hat{V}]\exp[-\tau\hat{T}]\exp[-(\tau/2)\hat{V}] |R'\right&gt;\)</span>.
This is exactly
<span class="math">\(\exp[-(\tau/2)(V(R)+V(R')]\exp[-(R-R')^2/(4\lambda\tau)]\)</span> where
<span class="math">\(V(R)\)</span> is the (Helium) potential. Generally, this approximation
introduces an error of order <span class="math">\(\mathcal O (\tau^2)\)</span> but is exact in
the limit <span class="math">\(\tau\rightarrow 0\)</span> and <span class="math">\(M \rightarrow \infty\)</span>.
Therefore, we must use a very small tau to maintain the validity of the
approximation.</p>
<p>We can produce a better approximation whose error is higher order in
<span class="math">\(\tau\)</span>, allowing us to use a much larger value and hence require
fewer time slices <span class="math">\(M\)</span> for a given <span class="math">\(\beta\)</span> (remember
<span class="math">\(M=\frac{\beta}{\tau}\)</span>). We do this by using the approximation
that the many body density matrix is a product of pair density matrices
<span class="math">\(\rho(R,R') \approx \prod_{ij} \rho(r_{ij})\)</span>. We can (effectively
exactly) calculate these pair density matrices between any two types of
particles in our system. Because we are doing a system of bulk Helium-4,
it has only one possible type of pair interaction, and we are only
required to specify/create the pair density matrix for He4-He4.
Constructing this interaction is an important but technically involved
process. To learn how to produce the relevant files, please see
<a class="reference external" href="Constructingadensitymatrix">Constructing a density matrix</a>. If
you want to skip this step for now, you may use the already prepared
files
(<a class="reference external" href="http://esler.physics.uiuc.edu/tutorial/liquidHelium/He4.95.dm">He4.95.dm</a>,
<a class="reference external" href="http://esler.physics.uiuc.edu/tutorial/liquidHelium/He4.95.Sampling.in">He4.95.Sampling.in</a>,
and
<a class="reference external" href="http://esler.physics.uiuc.edu/tutorial/liquidHelium/He4.95.OffDiag.PairAction">He4.95.OffDiag.PairAction</a>)
(Note: Make sure all these files are in the in the directory from which
you are running the code).</p>
<p>After constructing the files, we need to tell the code where to find
them. We do this by changing the variable <em>Array PairActionFiles(1)</em>
(Section: Action) and setting it to &#8220;[&#8220;He4.95.OffDiag.PairAction&#8221;]&#8221;.
This will ensure that the code can find the PairAction between He4
particles and other He4 particles. If we had other species <em>Types</em> in
our system, we would have to have a PairAction for each species type.</p>
<p>Finally, let&#8217;s set the time step <span class="math">\(\tau\)</span>. Because we have produced
a particularly accurate many body density matrix, we can use a much
higher value for tau then we would have otherwise. For, this tutorial
let us set <em>tau</em> (Section: System) to be 0.05. (This is actually still
somewhat large, but we want our tutorial to run quickly and will check
for convergence later). Remember when you choose tau that the value you
select must be in the density matrix file as well as all values of tau
required by the BisectionBlock Move (i.e. all powers up to
<span class="math">\(2^{level}\tau\)</span>).</p>
</div>
<div class="section" id="adding-observables">
<h1>Adding observables<a class="headerlink" href="#adding-observables" title="Permalink to this headline">¶</a></h1>
<p>At this point you should have a <a class="reference external" href="basicheliuminputfile">basic helium input
file</a> and should now be able to run the
Helium simulation. Although we haven&#8217;t set up anything to measure yet,
picked good moves, or tuned the Algorithm, run the Helium simulation now
to verify we&#8217;ve successfully changed our input. This will take a couple
minutes so start working on the next part of the tutorial as this is
happening. If you need to open a new terminal to do so don&#8217;t forget to
repeat the &#8220;source&#8221; action from the beginning of the tutorial, but do
not run the &#8220;setup_PIMC&#8221; script.</p>
<p>Now we would like to measure some aspects of our simulations. Many of
these measurements (<em>Observables</em>) will have to do with Helium, although
some of them deal with properties of our simulation, such as the
efficiency of the algorithm. We will start by setting up the
observables, and then we will add them to the algorithm. We will now set
up a number of observables. Let us start with the Structure Factor. We
begin with adding a</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Section</span> <span class="p">(</span><span class="n">Observable</span><span class="p">)</span>
</pre></div>
</div>
<p>inside of our Observables section. Its <em>Type</em> (Section:
Observables/Observable) will be &#8220;StructureFactor&#8221;. As before, we can
choose any <em>Name</em> (Section: Observables/Observable) we desire but then
must consistently use it throughout the rest of the input. For this
tutorial, let&#8217;s set the Name to &#8220;HeliumStructureFactor&#8221;. In order for
the structure factor to work appropriately, we have to specify the k
points at which <span class="math">\(S(k)\)</span> will be evaluated. There are two ways to do
this. To begin with, you can set a k-cutoff. If this is done, all k
points whose magnitude is less than this k-cutoff will be calculated (if
a long range action is being used, the k-cutoff from the long range
action is used automatically). This <em>kCutoff</em> (Section:
Observables/Observable) is set by specifying</p>
<div class="highlight-python"><pre>double kCutoff=5.0</pre>
</div>
<p>The other method is to specify a list of k-vectors explicitly. See the
documentation on the <a class="reference external" href="Observables#Structure_Factor">Structure Factor</a>
for the latter. Here we will just specify a k-cutoff of 5.0. We now must
set the Frequency which specifies how many times the observable is
called in the algorithm before it is measured. We will start by
specifying the <em>Frequency</em> (Section: Observables/Observable) to 25.
Later, if we find that this is taking too much time (or statistics are
not good) in our simulation, we will change this number. Finally,
specify the strings <em>Species1</em> and <em>Species2</em> (Section:
Observables/Observable) equal to &#8220;Helium4&#8221;. At this point your Structure
Factor observable should look like this:</p>
<div class="highlight-python"><pre>Section (Observable)
   {
     string Type="StructureFactor";
     string Name="HeliumStructureFactor";
     double kCutoff=5.0;
     int Frequency=25;
     string Species1="Helium4";
     string Species2="Helium4";

   }</pre>
</div>
<p>By following the documentation and this example, add observables for the
<a class="reference external" href="Observables#Superfluid_Fraction">Superfluid Fraction</a> ,
<a class="reference external" href="Observables#PathDump">PathDump</a> (set the Frequency to 100), and
<a class="reference external" href="Observables#Pair_Correlation_Function">Pair Correlation Function</a>.</p>
<p>Finally, let&#8217;s specify the <a class="reference external" href="Observables#Time_Analysis">Time Analysis</a>
observable. The code automatically calculates how much time is spent in
each observable and move in the system. By adding the Time Analysis
observable of our system, we are able to access this information and can
then do a more effective job of tuning the simulation.</p>
<p>Now that we&#8217;ve defined our observables, we have to place them into the
algorithm. To do this, let&#8217;s go to the Algorithm section of our
simulation. Here we can add in the new observables we have just declared
underneath the current observable. Make sure you use the &#8220;Name&#8221; that you
specified when you defined the observables. At this point, your file
should look like <a class="reference external" href="Helium_File_2">this</a></p>
<p>Now, go back and continue with the main tutorial.</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Changing System Parameters</a></li>
<li><a class="reference internal" href="#particle-statistics">Particle Statistics</a></li>
<li><a class="reference internal" href="#generating-density-matrix">Generating density matrix</a></li>
<li><a class="reference internal" href="#adding-observables">Adding observables</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/WritingHeliumInputfile.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="index.html">PIMC++ 1.0.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Ken Esler, Bryan Clark, Ethan Brown.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>